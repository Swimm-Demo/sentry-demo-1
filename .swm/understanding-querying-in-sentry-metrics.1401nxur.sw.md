---
title: Understanding Querying in Sentry Metrics
---
```mermaid
graph TD;
 A[Querying] --> B[QueryOrder];
 A --> C[QueryExpression];
 A --> D[QueryResult];
 D --> E[Transformation];
 D --> F[Post-processing];

 graph TD;
 A[Construct Query] --> B[Generate Queries];
 B --> C[Run Queries];
 C --> D[Process Results];
 D --> E[Analyze Data];

 graph TD;
 A[generate_queries] --> B[_parse_mql];
 B --> C[QueryValidationV2Visitor];
 B --> D[EnvironmentsInjectionVisitor];
 B --> E[QueryConditionsCompositeVisitor];
 C --> F[validate query];
 D --> G[inject environment filter];
 E --> H[transform conditions];
```

# Overview

Querying in Sentry metrics involves retrieving and processing metric data to gain insights into application performance and errors. It utilizes various components such as <SwmToken path="src/sentry/sentry_metrics/querying/types.py" pos="34:2:2" line-data="class QueryOrder(Enum):">`QueryOrder`</SwmToken>, <SwmToken path="src/sentry/sentry_metrics/querying/data/parsing.py" pos="64:9:9" line-data="    ) -&gt; Generator[tuple[QueryExpression, QueryOrder | None, int | None], None, None]:">`QueryExpression`</SwmToken>, and <SwmToken path="src/sentry/sentry_metrics/querying/data/execution.py" pos="582:10:10" line-data="    def to_query_result(self) -&gt; QueryResult:">`QueryResult`</SwmToken> to structure and execute queries. These components work together to enable efficient querying and analysis of metric data, helping developers identify and resolve issues in their applications.

<SwmSnippet path="/src/sentry/sentry_metrics/querying/types.py" line="34">

---

# <SwmToken path="src/sentry/sentry_metrics/querying/types.py" pos="34:2:2" line-data="class QueryOrder(Enum):">`QueryOrder`</SwmToken>

The <SwmToken path="src/sentry/sentry_metrics/querying/types.py" pos="34:2:2" line-data="class QueryOrder(Enum):">`QueryOrder`</SwmToken> class defines the order in which the query results should be sorted, either ascending or descending. This is crucial for organizing the results in a meaningful way.

```python
class QueryOrder(Enum):
    """
    Represents the order of the query.
    """

    ASC = "asc"
    DESC = "desc"

    @classmethod
    # Used `Union` because `|` conflicts with the parser.
    def from_string(cls, value: str) -> Union["QueryOrder", None]:
        for v in cls:
            if v.value == value:
                return v

        return None

    def to_snuba_order(self) -> Direction:
        if self == QueryOrder.ASC:
            return Direction.ASC
        elif self == QueryOrder.DESC:
```

---

</SwmSnippet>

<SwmSnippet path="/src/sentry/sentry_metrics/querying/data/parsing.py" line="36">

---

# <SwmToken path="src/sentry/sentry_metrics/querying/data/parsing.py" pos="64:9:9" line-data="    ) -&gt; Generator[tuple[QueryExpression, QueryOrder | None, int | None], None, None]:">`QueryExpression`</SwmToken>

The <SwmToken path="src/sentry/sentry_metrics/querying/data/parsing.py" pos="36:3:3" line-data="    def _parse_mql(self, mql: str) -&gt; VisitableQueryExpression:">`_parse_mql`</SwmToken> function parses the MQL (Metrics Query Language) string into a <SwmToken path="src/sentry/sentry_metrics/querying/data/parsing.py" pos="36:16:16" line-data="    def _parse_mql(self, mql: str) -&gt; VisitableQueryExpression:">`VisitableQueryExpression`</SwmToken>, which represents the expressions used in the query to filter or compute metrics. This parsed expression allows visitors to be applied for further processing and validation.

```python
    def _parse_mql(self, mql: str) -> VisitableQueryExpression:
        """
        Parses the field with the MQL grammar.

        Returns:
            A VisitableQueryExpression that wraps the AST generated by the query string and allows visitors to
            be applied on top.
        """
        try:
            query = parse_mql(mql)
        except InvalidMQLQueryError as e:
            metrics.incr(key="ddm.metrics_api.parsing.error")
            cause = e.__cause__
            if cause and isinstance(cause, IncompleteParseError):
                error_context = cause.text[cause.pos : cause.pos + 20]
                # We expose the entire MQL string to give more context when solving the error, since in the future we
                # expect that MQL will be directly fed into the endpoint instead of being built from the supplied
                # fields.
                raise InvalidMetricsQueryError(
                    f"The query '{mql}' could not be matched starting from '{error_context}...'"
                ) from e
```

---

</SwmSnippet>

<SwmSnippet path="/src/sentry/sentry_metrics/querying/data/execution.py" line="569">

---

# <SwmToken path="src/sentry/sentry_metrics/querying/data/execution.py" pos="582:10:10" line-data="    def to_query_result(self) -&gt; QueryResult:">`QueryResult`</SwmToken>

The <SwmToken path="src/sentry/sentry_metrics/querying/data/execution.py" pos="569:2:2" line-data="class PartialQueryResult:">`PartialQueryResult`</SwmToken> class represents a partial query result, which can be transformed into a <SwmToken path="src/sentry/sentry_metrics/querying/data/execution.py" pos="582:10:10" line-data="    def to_query_result(self) -&gt; QueryResult:">`QueryResult`</SwmToken> containing the data of the last executed query. This transformation is essential for obtaining the final results of a series of dependent queries.

```python
class PartialQueryResult:
    """
    Represents a partial query result which contains all the queries that are linearly dependent and their results.

    This result is stored in the array of results for each ScheduledQuery that has a next parameter.

    Attributes:
        previous_queries: All the previous queries that have been executed as part of a single list of chained queries,
            defined via the next parameter of ScheduledQuery.
    """

    previous_queries: list[tuple[ScheduledQuery, Mapping[str, Any], bool]]

    def to_query_result(self) -> QueryResult:
        """
        Transforms a PartialQueryResult in a QueryResult by taking the last query that was executed in the list.

        Returns:
            A QueryResult which contains the data of the last query executed as part of this PartialQueryResult.
        """
        # For now, we naively return the first scheduled query and result, but this is just because
```

---

</SwmSnippet>

<SwmSnippet path="/src/sentry/sentry_metrics/querying/data/parsing.py" line="62">

---

# Generating Queries

The <SwmToken path="src/sentry/sentry_metrics/querying/data/parsing.py" pos="62:3:3" line-data="    def generate_queries(">`generate_queries`</SwmToken> function generates multiple queries from a base query, compiling and parsing them into <SwmToken path="src/sentry/sentry_metrics/querying/data/parsing.py" pos="64:9:9" line-data="    ) -&gt; Generator[tuple[QueryExpression, QueryOrder | None, int | None], None, None]:">`QueryExpression`</SwmToken> objects. This function utilizes various visitors to validate the query, inject environment filters, and transform conditions.

```python
    def generate_queries(
        self,
    ) -> Generator[tuple[QueryExpression, QueryOrder | None, int | None], None, None]:
        """
        Generates multiple queries given a base query.

        Returns:
            A generator which can be used to obtain a query to execute and its details.
        """
        for mql_query in self._mql_queries:
            compiled_mql_query = mql_query.compile()

            query_expression = (
                self._parse_mql(compiled_mql_query.mql)
                # We validate the query.
                .add_visitor(QueryValidationV2Visitor())
                # We inject the environment filter in each timeseries.
                .add_visitor(EnvironmentsInjectionVisitor(self._environments))
                # We transform all `release:latest` filters into the actual latest releases.
                .add_visitor(
                    QueryConditionsCompositeVisitor(
```

---

</SwmSnippet>

<SwmSnippet path="/src/sentry/sentry_metrics/querying/data/api.py" line="29">

---

# Running Queries

The <SwmToken path="src/sentry/sentry_metrics/querying/data/api.py" pos="29:2:2" line-data="def run_queries(">`run_queries`</SwmToken> function executes a list of MQL queries, processes the results, and returns an <SwmToken path="src/sentry/sentry_metrics/querying/data/api.py" pos="39:4:4" line-data=") -&gt; MQLQueriesResult:">`MQLQueriesResult`</SwmToken> object for further analysis. This function is responsible for the actual execution of the queries and the initial processing of the results.

```python
def run_queries(
    mql_queries: Sequence[MQLQuery],
    start: datetime,
    end: datetime,
    interval: int,
    organization: Organization,
    projects: Sequence[Project],
    environments: Sequence[Environment],
    referrer: str,
    query_type: QueryType = QueryType.TOTALS_AND_SERIES,
) -> MQLQueriesResult:
    """
    Runs a list of MQLQuery(s) that are executed in Snuba.

    Returns:
        A MQLQueriesResult object which encapsulates the results of the plan and allows a QueryTransformer
        to be run on the data.
    """
    # We build the basic query that contains the metadata which will be shared across all queries.
    base_query = MetricsQuery(
        start=start,
```

---

</SwmSnippet>

&nbsp;

*This is an auto-generated document by Swimm AI ðŸŒŠ and has not yet been verified by a human*

<SwmMeta version="3.0.0" repo-id="Z2l0aHViJTNBJTNBc2VudHJ5LWRlbW8tMSUzQSUzQVN3aW1tLURlbW8=" repo-name="sentry-demo-1" doc-type="overview"><sup>Powered by [Swimm](/)</sup></SwmMeta>
